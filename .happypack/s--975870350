'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 *  * postal.federation - A base plugin for federating instances of postal.js across various boundaries.
 *  * Author: Jim Cowart (http://ifandelse.com)
 *  * Version: v0.5.3
 *  * Url: http://github.com/postaljs/postal.federation
 *  * License(s): (MIT OR GPL-2.0)
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory(require("lodash"), require("postal"));else if (typeof define === 'function' && define.amd) define(["lodash", "postal"], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["postalFedx"] = factory(require("lodash"), require("postal"));else root["postalFedx"] = factory(root["_"], root["postal"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			var _ = _interopRequire(__webpack_require__(1));

			var postal = _interopRequire(__webpack_require__(2));

			__webpack_require__(3);

			var _packingSlips = __webpack_require__(4);

			var packingSlips = _packingSlips.packingSlips;
			var getPackingSlip = _packingSlips.getPackingSlip;

			var _state = __webpack_require__(5);

			var state = _state.state;
			var disconnect = _state.disconnect;
			var NO_OP = _state.NO_OP;
			var configure = _state.configure;

			var _handlers = __webpack_require__(6);

			var handlers = _handlers.handlers;
			var onFederatedMsg = _handlers.onFederatedMsg;

			var _filters = __webpack_require__(7);

			var filters = _interopRequire(_filters);

			var matchesFilter = _filters.matchesFilter;
			var addFilter = _filters.addFilter;
			var removeFilter = _filters.removeFilter;

			var FederationClient = _interopRequire(__webpack_require__(8));

			var fedx = postal.fedx = {
				FederationClient: FederationClient,
				packingSlips: packingSlips,
				handlers: handlers,
				clients: state._clients,
				transports: state._transports,
				filters: filters,
				addFilter: addFilter,
				removeFilter: removeFilter,
				canSendRemote: function canSendRemote(channel, topic) {
					return matchesFilter(channel, topic, "out");
				},
				configure: configure,
				getPackingSlip: getPackingSlip,
				onFederatedMsg: onFederatedMsg,
				sendMessage: function sendMessage(envelope) {
					if (!state._ready) {
						state._outboundQueue.push(arguments);
						return;
					}
					_.each(this.transports, function (transport) {
						transport.sendMessage(envelope);
					});
				},
				disconnect: disconnect,
				_getTransports: function _getTransports() {
					return _.reduce(this.transports, function (memo, transport, name) {
						memo[name] = true;
						return memo;
					}, {});
				},
				/*
    	signalReady( callback );
    	signalReady( "transportName" );
    	signalReady( "transportName", callback );
    	signalReady( "transportName", targetInstance, callback ); <-- this is NEW
    	signalReady( { transportNameA: targetsForA, transportNameB: targetsForB, transportC: true }, callback);
    */
				signalReady: function signalReady(transport, target, callback) {
					if (!state._ready) {
						state._signalQueue.push(arguments);
						return;
					}
					var transports = this._getTransports();
					switch (arguments.length) {
						case 1:
							if (typeof transport === "function") {
								callback = transport;
							} else if (typeof transport === "string") {
								transports = {};
								transports[transport] = this.transports[transport];
								callback = NO_OP;
							}
							break;
						case 2:
							if (typeof transport === "string") {
								transports = {};
								transports[transport] = this.transports[transport];
							} else {
								transports = transport;
							}
							callback = target || NO_OP;
							break;
						case 3:
							transports = {};
							transports[transport] = [target];
							break;
					}
					_.each(transports, function (targets, name) {
						targets = typeof targets === "boolean" ? [] : targets;
						this.transports[name].signalReady(targets, callback);
					}, this);
				}
			};

			module.exports = fedx;

			function processSignalQ(args) {
				fedx.signalReady.apply(this, args);
			}

			function processOutboundQ(args) {
				fedx.send.apply(this, args);
			}

			function processInboundQ(msg) {
				fedx.onFederatedMsg.call(this, msg);
			}

			postal.addWireTap(function (data, envelope) {
				if (fedx.canSendRemote(envelope.channel, envelope.topic)) {
					fedx.sendMessage(envelope);
				}
			});

			postal.subscribe({
				channel: postal.configuration.SYSTEM_CHANNEL,
				topic: "instanceId.changed",
				callback: function callback() {
					state._ready = true;
					while (state._signalQueue.length) {
						processSignalQ(state._signalQueue.shift());
					}
					while (state._outboundQueue.length) {
						processOutboundQ(state._outboundQueue.shift());
					}
					while (state._inboundQueue.length) {
						processInboundQ(state._inboundQueue.shift());
					}
				}
			});

			if (postal.instanceId() !== undefined) {
				state._ready = true;
			}

			/***/
		},
		/* 1 */
		/***/function (module, exports) {

			module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			var postal = _interopRequire(__webpack_require__(2));

			if (!postal.createUUID) {
				postal.createUUID = function () {
					var s = [];
					var hexDigits = "0123456789abcdef";
					for (var i = 0; i < 36; i++) {
						s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
					}
					s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
					/* jshint ignore:start */
					s[19] = hexDigits.substr(s[19] & 3 | 8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
					/* jshint ignore:end */
					s[8] = s[13] = s[18] = s[23] = "-";
					return s.join("");
				};
			}
			if (!postal.instanceId) {
				postal.instanceId = function () {
					var _id = undefined,
					    _oldId = undefined;
					return function (id) {
						if (id) {
							_oldId = _id;
							_id = id;
							postal.publish({
								channel: postal.configuration.SYSTEM_CHANNEL,
								topic: "instanceId.changed",
								data: {
									oldId: _oldId,
									newId: _id
								}
							});
						}
						return _id;
					};
				}();
			}

			/***/
		},
		/* 4 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			exports.getPackingSlip = getPackingSlip;
			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var postal = _interopRequire(__webpack_require__(2));

			function getPackingSlip(type /*, env */) {
				if (Object.prototype.hasOwnProperty.call(packingSlips, type)) {
					return packingSlips[type].apply(this, Array.prototype.slice.call(arguments, 1));
				}
			}

			var packingSlips = {
				ping: function ping() {
					return {
						type: "federation.ping",
						instanceId: postal.instanceId(),
						timeStamp: new Date(),
						ticket: postal.createUUID()
					};
				},
				pong: function pong(ping) {
					return {
						type: "federation.pong",
						instanceId: postal.instanceId(),
						timeStamp: new Date(),
						pingData: {
							instanceId: ping.instanceId,
							timeStamp: ping.timeStamp,
							ticket: ping.ticket
						}
					};
				},
				message: function message(env) {
					return {
						type: "federation.message",
						instanceId: postal.instanceId(),
						timeStamp: new Date(),
						envelope: env
					};
				},
				disconnect: function disconnect() {
					return {
						type: "federation.disconnect",
						instanceId: postal.instanceId(),
						timeStamp: new Date()
					};
				},
				bundle: function bundle(packingSlips) {
					return {
						type: "federation.bundle",
						instanceId: postal.instanceId(),
						timeStamp: new Date(),
						packingSlips: packingSlips
					};
				}
			};
			exports.packingSlips = packingSlips;

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			exports.configure = configure;
			exports.disconnect = disconnect;
			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _ = _interopRequire(__webpack_require__(1));

			var _defaults = {
				enabled: true,
				filterMode: "whitelist",
				filterDirection: "both"
			};

			var NO_OP = function NO_OP() {};

			exports.NO_OP = NO_OP;
			var state = {
				_clients: [],
				_transports: {},
				_ready: false,
				_inboundQueue: [],
				_outboundQueue: [],
				_signalQueue: [],
				_config: _defaults
			};

			exports.state = state;

			function configure(cfg) {
				if (cfg && cfg.filterMode && cfg.filterMode !== "blacklist" && cfg.filterMode !== "whitelist") {
					throw new Error("postal.fedx filterMode must be 'blacklist' or 'whitelist'.");
				}
				if (cfg) {
					state._config = _.defaults(cfg, _defaults);
				}
				return state._config;
			}

			function disconnect(options) {
				options = options || {};
				var trans = state._transports;
				if (options.transport) {
					trans = {};
					trans[options.transport] = state._transports[options.transport];
				}
				_.each(trans, function (t) {
					t.disconnect({
						target: options.target,
						instanceId: options.instanceId,
						doNotNotify: !!options.doNotNotify
					});
				});
			}

			/***/
		},
		/* 6 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			exports.onFederatedMsg = onFederatedMsg;
			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var getPackingSlip = __webpack_require__(4).getPackingSlip;

			var _state = __webpack_require__(5);

			var state = _state.state;
			var disconnect = _state.disconnect;

			var matchesFilter = __webpack_require__(7).matchesFilter;

			var postal = _interopRequire(__webpack_require__(2));

			var _ = _interopRequire(__webpack_require__(1));

			var handlers = {
				"federation.ping": function federationPing(data /*, callback */) {
					data.source.setInstanceId(data.packingSlip.instanceId);
					if (data.source.handshakeComplete) {
						data.source.sendPong(data.packingSlip);
					} else {
						data.source.sendBundle([getPackingSlip("pong", data.packingSlip), getPackingSlip("ping")]);
					}
				},
				"federation.pong": function federationPong(data) {
					data.source.handshakeComplete = true;
					data.source.setInstanceId(data.packingSlip.instanceId);
					if (data.source.pings[data.packingSlip.pingData.ticket]) {
						data.source.pings[data.packingSlip.pingData.ticket].callback({
							ticket: data.packingSlip.pingData.ticket,
							instanceId: data.packingSlip.instanceId,
							source: data.source
						});
						data.source.pings[data.packingSlip.pingData.ticket] = undefined;
					}
					if (!_.contains(state._clients, data.packingSlip.instanceId)) {
						state._clients.push(data.packingSlip.instanceId);
					}
					postal.publish({
						channel: "postal.federation",
						topic: "client.federated",
						data: {
							remoteId: data.source.instanceId,
							localId: postal.instanceId(),
							transport: data.transport
						}
					});
				},
				"federation.disconnect": function federationDisconnect(data) {
					state._clients = _.without(state._clients, data.source.instanceId);
					disconnect({
						transport: data.source.transportName,
						instanceId: data.source.instanceId,
						doNotNotify: true
					});
				},
				"federation.message": function federationMessage(data) {
					var env = data.packingSlip.envelope;
					if (matchesFilter(env.channel, env.topic, "in")) {
						env.lastSender = data.packingSlip.instanceId;
						postal.publish(env);
					}
				},
				"federation.bundle": function federationBundle(data) {
					_.each(data.packingSlip.packingSlips, function (slip) {
						onFederatedMsg(_.extend({}, data, {
							packingSlip: slip
						}));
					});
				}
			};

			exports.handlers = handlers;

			function onFederatedMsg(data) {
				if (!state._ready) {
					state._inboundQueue.push(data);
					return;
				}
				if (Object.prototype.hasOwnProperty.call(handlers, data.packingSlip.type)) {
					handlers[data.packingSlip.type](data);
				} else {
					throw new Error("postal.federation does not have a message handler for '" + data.packingSlip.type + "'.");
				}
			}

			/***/
		},
		/* 7 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			exports.addFilter = addFilter;
			exports.removeFilter = removeFilter;
			exports.matchesFilter = matchesFilter;
			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _ = _interopRequire(__webpack_require__(1));

			var state = __webpack_require__(5).state;

			var postal = _interopRequire(__webpack_require__(2));

			var filters = {
				"in": {}, // jscs:ignore disallowQuotedKeysInObjects
				out: {}
			};

			exports["default"] = filters;

			function addFilter(_filters) {
				_filters = _.isArray(_filters) ? _filters : [_filters];
				_.each(_filters, function (filter) {
					filter.direction = filter.direction || state._config.filterDirection;
					_.each(filter.direction === "both" ? ["in", "out"] : [filter.direction], function (dir) {
						if (!filters[dir][filter.channel]) {
							filters[dir][filter.channel] = [filter.topic];
						} else if (!_.include(filters[dir][filter.channel], filter.topic)) {
							filters[dir][filter.channel].push(filter.topic);
						}
					});
				});
			}

			function removeFilter(_filters) {
				_filters = _.isArray(_filters) ? _filters : [_filters];
				_.each(_filters, function (filter) {
					filter.direction = filter.direction || state._config.filterDirection;
					_.each(filter.direction === "both" ? ["in", "out"] : [filter.direction], function (dir) {
						if (filters[dir][filter.channel] && _.include(filters[dir][filter.channel], filter.topic)) {
							filters[dir][filter.channel] = _.without(filters[dir][filter.channel], filter.topic);
						}
					});
				});
			}

			function matchesFilter(channel, topic, direction) {
				var channelPresent = Object.prototype.hasOwnProperty.call(filters[direction], channel);
				var topicMatch = channelPresent && _.any(filters[direction][channel], function (binding) {
					return postal.configuration.resolver.compare(binding, topic);
				});
				var blacklisting = state._config.filterMode === "blacklist";
				return state._config.enabled && (blacklisting && (!channelPresent || channelPresent && !topicMatch) || !blacklisting && channelPresent && topicMatch);
			}

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			// istanbul ignore next

			var _interopRequire = function _interopRequire(obj) {
				return obj && obj.__esModule ? obj["default"] : obj;
			};

			// istanbul ignore next

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var key in props) {
						var prop = props[key];prop.configurable = true;if (prop.value) prop.writable = true;
					}Object.defineProperties(target, props);
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			// istanbul ignore next

			var _classCallCheck = function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			};

			var getPackingSlip = __webpack_require__(4).getPackingSlip;

			var onFederatedMsg = __webpack_require__(6).onFederatedMsg;

			var _state = __webpack_require__(5);

			var state = _state.state;
			var NO_OP = _state.NO_OP;

			var postal = _interopRequire(__webpack_require__(2));

			var _ = _interopRequire(__webpack_require__(1));

			var FederationClient = function () {
				function FederationClient(target, options, instanceId) {
					_classCallCheck(this, FederationClient);

					this.target = target;
					this.options = options || {};
					this.pings = {};
					this.instanceId = instanceId;
					this.handshakeComplete = false;
				}

				_createClass(FederationClient, {
					sendPing: {
						value: function sendPing(callback) {
							var packingSlip = getPackingSlip("ping");
							this.pings[packingSlip.ticket] = {
								ticket: packingSlip.ticket,
								callback: callback || NO_OP
							};
							this.send(packingSlip);
						}
					},
					sendPong: {
						value: function sendPong(origPackingSlip) {
							this.send(getPackingSlip("pong", origPackingSlip));
						}
					},
					sendBundle: {
						value: function sendBundle(slips) {
							this.send(getPackingSlip("bundle", slips));
						}
					},
					sendMessage: {
						value: function sendMessage(envelope) {
							if (!this.handshakeComplete) {
								return;
							}
							envelope.originId = envelope.originId || postal.instanceId();
							var env = _.clone(envelope);
							if (this.instanceId && this.instanceId !== env.lastSender && (!env.knownIds || !env.knownIds.length || env.knownIds && !_.include(env.knownIds, this.instanceId))) {
								env.knownIds = (env.knownIds || []).concat(_.without(state._clients, this.instanceId));
								this.send(getPackingSlip("message", env));
							}
						}
					},
					disconnect: {
						value: function disconnect() {
							this.send(getPackingSlip("disconnect"));
						}
					},
					onMessage: {
						value: function onMessage(packingSlip) {
							if (this.shouldProcess()) {
								onFederatedMsg({
									transport: this.transportName,
									packingSlip: packingSlip,
									source: this
								});
							}
						}
					},
					shouldProcess: {
						value: function shouldProcess() {
							return true;
						}
					},
					send: {
						value: function send() {
							throw new Error("An object deriving from FederationClient must provide an implementation for 'send'.");
						}
					},
					setInstanceId: {
						value: function setInstanceId(id) {
							this.instanceId = id;
						}
					}
				}, {
					extend: {
						value: function extend(props, ctrProps) {
							function FedXClient() {
								FederationClient.apply(this, arguments);
							}

							FedXClient.prototype = Object.create(FederationClient.prototype);
							_.extend(FedXClient.prototype, props);
							_.extend(FedXClient, ctrProps);

							return FedXClient;
						}
					}
				});

				return FederationClient;
			}();

			module.exports = FederationClient;
			/* msg */

			/***/
		}
		/******/])
	);
});
;